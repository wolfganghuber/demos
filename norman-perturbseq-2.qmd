---
title: "Explore the Norman data"
subtitle: "Step 2: Explore"
author: "Wolfgang Huber"
date: "2026-01-02"
format:
  html:
    embed-resources: false
    page-layout: full
    css: wh.css
    toc: true
execute:
  fig-align: center
---

# Setup

```{r}
#| label: setup
#| echo: !expr -1
#| message: false
#| warning: false
knitr::opts_chunk$set(cache = TRUE, autodep = TRUE, width = 80)
library("assertthat")
library("dplyr")
library("tidyr")
library("ggplot2")
```

# Load result from `norman-perturbseq-1.qmd`

```{r}
#| label: load
load("norman-perturbseq-mat.RData")
ls()
dim(mat)
```

# Size Factors

```{r}
#| label: sizefactors1
#| fig.dim: !expr c(8, 3)
sf = DESeq2::estimateSizeFactorsForMatrix(mat)
last(colnames(mat))
ggplot(tibble(i = seq(along = sf), sf = sf), aes(x = i, y = sf)) + 
  geom_point() + scale_y_log10()
```
```{r}
#| label: sizefactors2
#| fig.dim: !expr c(3, 3)
ggplot(tibble(sum = colSums(mat), sf = sf), aes(x = sum, y = sf)) + 
  geom_point() +
  scale_x_log10() + scale_y_log10()
```

```{r}
#| label: normalize
nmat = mat
for(i in seq_along(sf))
  nmat[,i] = nmat[,i] / sf[i]
```

The `DESeq2` size factors are highly similar to the total library counts. They vary by about a factor of 10, which seems OK, except for the very last one. Let's check that it is sane.

# Prepare for comparing double to single perturbations

## Find our way around and arrange 

```{r}
#| label: perts
perts = stringr::str_split_fixed(colnames(nmat), pattern = stringr::fixed("+"), 2)
head(perts)
table(perts)
```

Find the double perturbations (`doubles`) and the corresponding pair of single perturbations (`single1`, `single2`). `combs` is a dataframe with indices into the columns of `nmat`

```{r}
#| label: combs
is_ctrl1 = perts[, 1] %in% c("ctrl", "")
is_ctrl2 = perts[, 2] %in% c("ctrl", "")
assert_that(!any(is_ctrl1[-length(is_ctrl1)])) |> invisible()
doubles = which(!is_ctrl2)
combs = lapply(seq_along(doubles), function(i) {
  s1 = which(perts[, 1] == perts[ doubles[i], 1] & is_ctrl2)
  s2 = which(perts[, 1] == perts[ doubles[i], 2] & is_ctrl2)
  assert_that(length(s1) == 1, length(s2) == 1)
  tibble(double = doubles[i], single1 = s1, single2 = s2)
}) |> bind_rows()
combs
combsdf = data.frame(
  double  = colnames(nmat)[combs$double], 
  single1 = colnames(nmat)[combs$single1], 
  single2 = colnames(nmat)[combs$single2]
) 
knitr::kable(combsdf) |>
  kableExtra::kable_paper() |>
  kableExtra::scroll_box(height = "300px")
```

```{r}
#| label: checkctrl
#| fig.dim: !expr c(10, 11)
sampledcolumns = sample(colnames(mat)[-ncol(mat)], 25)
nmat[, c(sampledcolumns, last(colnames(mat)))] |>
  as_tibble() |>
  mutate(row_id = seq_len(nrow(mat))) |>
  pivot_longer(cols = all_of(sampledcolumns), 
               names_to = "sample", 
               values_to = "value") |>
  ggplot(aes(x = asinh(ctrl), y = asinh(value))) + 
    geom_point(size = 0.1) + 
    geom_abline(slope = 1, col = "red") +
    coord_fixed() +
    facet_wrap(vars(sample))
```

## Dimension reduction

We 

- select the top 500 most highly expressed genes,
- could, but do not remove the mitochondrial and ribosomal genes,
- compute logratios,
- perform PCA (without scaling)

```{r}
#| label: dimred
#| fig.dim: !expr c(5, 2.9)
ntop = 500
snmat = nmat[order(rowMeans(nmat), decreasing = TRUE)[1:ntop], ]

if (FALSE) {
  mito = grepl("^MT-", rownames(snmat))
  ribo = grepl("^RP",  rownames(snmat))
  c(sum(mito), sum(ribo))
  snmat = snmat[!(mito|ribo), ]
  dim(snmat)
  rownames(snmat)
}

lrmat = log2(snmat[, colnames(snmat) != "ctrl"]) - log2(snmat[, "ctrl"])

pca = prcomp(t(lrmat), center = TRUE, scale. = FALSE)
plot(pca)
lapply(c("PC1", "PC2"), function(i)
  sort(abs(pca$rotation[, i]), decreasing = TRUE)[1:40] |> names() |> paste(collapse = ", ")
)
```

Claude summarized the above genes like this:

**PC axis 1**: These genes are primarily involved in:

- Hemoglobin production (HBG1, HBZ, HBG2) - oxygen transport
- Blood group antigens (GYPA, GYPB, GYPC) - red blood cell surface markers
- Cellular housekeeping - protein synthesis, energy metabolism, cytoskeleton organization, vesicle trafficking, and general cell maintenance functions

**PC axis 2**: These genes overlap significantly with your first list but add more:

- Hemoglobin/blood antigens (HBG1, HBG2, HBZ, GYPA, GYPB) - same as before
- RNA processing & translation (DDX21, NOP56, EIF1AX, HNRNPAB, MRPS12) - ribosome function, protein synthesis
- Metabolism & energy (VDAC1, ENO1, HSPD1, PRDX5) - mitochondrial function, glycolysis, antioxidant activity
- Cell cycle regulation (CDK4, UBE2S)
Overall: basic cellular metabolism, protein production, and stress responses.

K562 is a CML cell line with the  BCR-ABL1-fusion.

```{r}
#| label: plotpca
#| fig.dim: !expr c(24, 18)
#| warning: false
pca2d = as_tibble(pca$x[, c("PC1", "PC2")], rownames = "condition") |> mutate(is_ctrl = is_ctrl2[-length(is_ctrl2)])
ggplot(pca2d, aes(x = PC1, y = PC2, label = condition, col = is_ctrl)) + 
  scale_colour_manual(values = c(`TRUE` = "blue3", `FALSE` = "darkorange3")) + 
  geom_point() + ggrepel::geom_label_repel() + coord_fixed()
pca$sdev[1:2]^2 |> signif(3)
with(pca2d, c(var(PC1), var(PC2))) |> round(3)
```

The dimension reduced data with which we continue:

```{r}
#| label: dx
ndim = 10
dx = t(pca$x[, 1:ndim])
dx[1:3, seq_len(min(c(8, ndim)))] |> signif(3)
dim(dx)
dx %*% t(dx) |> signif(3)
```

Note the orthogonality.


## Fit linear models

```{r}
#| label: fitlm
fits = lapply(seq_len(nrow(combs)), function(i) {
  df = tibble(
    y  = dx[, combs$double[i]],
    x1 = dx[, combs$single1[i]],
    x2 = dx[, combs$single2[i]])
  ## angle between x1 and x2
  df |> with(180/pi*acos(sum(x1*x2)/sqrt(sum(x1*x1)*sum(x2*x2)))) |> signif(3) |>  print() 
  fit = lm(y ~ 0 + x1 + x2, data = df)
  tibble(beta1 = coef(fit)["x1"], beta2 = coef(fit)["x2"], res = mean(residuals(fit)^2), rsq = summary(fit)$r.squared)
}) |> bind_rows() |> bind_cols(combs)
```
```{r}
#| label: showfit
#| fig.dim: !expr c(5, 3)
#| out.width: "100%"
#| eval: true
r = range(with(fits, c(beta1, beta2)))
b = floor(r[1]):ceiling(r[2])
ggplot(fits, aes(x = beta1, y = beta2, col = rsq)) + 
  geom_abline(slope = -1, intercept = 1) + geom_point() + coord_fixed() + scale_x_continuous(breaks = b) + scale_y_continuous(breaks = b)
# col = res <= median(res))
b = seq(-2, 2, by = 0.5)
ggplot(fits, aes(x = beta1, y = beta2, col = rsq)) + 
  geom_abline(slope = -1, intercept = 1) + geom_point() + coord_fixed() + xlim(-2,2) + ylim(-2,2)
```