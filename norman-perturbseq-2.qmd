---
title: "Explore the Norman data"
subtitle: "Step 2: Explore"
author: "Wolfgang Huber"
date: "2026-01-02"
format:
  html:
    embed-resources: false
    page-layout: full
    css: wh.css
    toc: true
    lightbox: true
    theme: spacelab
execute:
  fig-align: center
---

# Setup

```{r}
#| label: setup
#| echo: !expr -1
#| message: false
#| warning: false
knitr::opts_chunk$set(cache = TRUE, autodep = TRUE, width = 120)
library("assertthat")
library("dplyr")
library("tidyr")
library("ggplot2")
```

# Load result from `norman-perturbseq-1.qmd`

```{r}
#| label: load
load("norman-perturbseq-mat.RData")
ls()
dim(mat)
```

# Size Factors

```{r}
#| label: sizefactors1
#| fig.dim: !expr c(8, 3)
sf = DESeq2::estimateSizeFactorsForMatrix(mat)
last(colnames(mat))
ggplot(tibble(i = seq(along = sf), sf = sf), aes(x = i, y = sf)) + 
  geom_point() + scale_y_log10()
```
```{r}
#| label: sizefactors2
#| fig.dim: !expr c(3, 3)
ggplot(tibble(sum = colSums(mat), sf = sf), aes(x = sum, y = sf)) + 
  geom_point() +
  scale_x_log10() + scale_y_log10()
```

```{r}
#| label: normalize
nmat = mat
for(i in seq_along(sf))
  nmat[,i] = nmat[,i] / sf[i]
```

The `DESeq2` size factors are highly similar to the total library counts. They vary by about a factor of 10, which seems OK, except for the very last one, which is the unperturbed control. Let's check that it is sane. We do a scatterplot of it versus 25 randomly sampled perturbations (single or double).

```{r}
#| label: checkctrl
#| fig.dim: !expr c(10, 11)
sampledcolumns = sample(colnames(nmat)[-ncol(nmat)], 25)
nmat[, c(sampledcolumns, last(colnames(nmat)))] |>
  as_tibble() |>
  mutate(row_id = seq_len(nrow(nmat))) |>
  pivot_longer(cols = all_of(sampledcolumns), 
               names_to = "sample", 
               values_to = "value") |>
  ggplot(aes(x = asinh(ctrl), y = asinh(value))) + 
    geom_point(size = 0.1) + 
    geom_abline(slope = 1, col = "red") +
    coord_fixed() +
    facet_wrap(vars(sample), ncol = 5)
```

# Prepare for comparing double to single perturbations

## Find our way around and arrange 

```{r}
#| label: perts
perts = stringr::str_split_fixed(colnames(nmat), pattern = stringr::fixed("+"), 2)
head(perts)
table(perts)
```

Find the double perturbations (`doubles`) and the corresponding pair of single perturbations (`single1`, `single2`). `combs` is a dataframe with indices into the columns of `nmat`

```{r}
#| label: combs
is_ctrl1 = perts[, 1] %in% c("ctrl", "")
is_ctrl2 = perts[, 2] %in% c("ctrl", "")
assert_that(
  last(is_ctrl1) && last(is_ctrl2),  # last sample is non-perturbed control
  !any(is_ctrl1[-length(is_ctrl1)])  # all except for the very last sample should not have 'ctrl' in column 1
) |> invisible() 
doubles = which(!is_ctrl2)
combs = lapply(seq_along(doubles), function(i) {
  s1 = which(perts[, 1] == perts[ doubles[i], 1] & is_ctrl2)
  s2 = which(perts[, 1] == perts[ doubles[i], 2] & is_ctrl2)
  assert_that(length(s1) == 1, length(s2) == 1)
  tibble(double = doubles[i], single1 = s1, single2 = s2)
}) |> bind_rows()
combs
combsdf = data.frame(
  double  = colnames(nmat)[combs$double], 
  single1 = colnames(nmat)[combs$single1], 
  single2 = colnames(nmat)[combs$single2]
) 
knitr::kable(combsdf) |>
  kableExtra::kable_paper() |>
  kableExtra::scroll_box(height = "300px")
```

## Dimension reduction

We 

- select the top 500 most highly expressed genes,
- could, but do not remove the mitochondrial and ribosomal genes,
- compute logratios,
- perform PCA (without scaling)

```{r}
#| label: dimred1
ntop = 500
snmat = nmat[order(rowMeans(nmat), decreasing = TRUE)[1:ntop], ]

if (FALSE) {
  mito = grepl("^MT-", rownames(snmat))
  ribo = grepl("^RP",  rownames(snmat))
  c(sum(mito), sum(ribo))
  snmat = snmat[!(mito|ribo), ]
  dim(snmat)
  rownames(snmat)
}

lrmat = log2(snmat[, seq_len(ncol(snmat)-1)]) - log2(snmat[, ncol(snmat)])  # as established above, the last column is the control 
```
```{r}
#| label: dimred2
#| fig.dim: !expr c(5, 2.6)
pca = prcomp(t(lrmat), center = TRUE, scale. = FALSE)
plot(pca)
lapply(c("PC1", "PC2"), function(i)
  sort(abs(pca$rotation[, i]), decreasing = TRUE)[1:40] |> names() |> paste(collapse = ", ")
)
```

Claude summarized the above genes like this:

**PC axis 1**: These genes are primarily involved in:

- Hemoglobin production (HBG1, HBZ, HBG2) - oxygen transport
- Blood group antigens (GYPA, GYPB, GYPC) - red blood cell surface markers
- Cellular housekeeping - protein synthesis, energy metabolism, cytoskeleton organization, vesicle trafficking, and general cell maintenance functions

**PC axis 2**: These genes overlap significantly with your first list but add more:

- Hemoglobin/blood antigens (HBG1, HBG2, HBZ, GYPA, GYPB) - same as before
- RNA processing & translation (DDX21, NOP56, EIF1AX, HNRNPAB, MRPS12) - ribosome function, protein synthesis
- Metabolism & energy (VDAC1, ENO1, HSPD1, PRDX5) - mitochondrial function, glycolysis, antioxidant activity
- Cell cycle regulation (CDK4, UBE2S)
Overall: basic cellular metabolism, protein production, and stress responses.

K562 is a CML cell line with the  BCR-ABL1-fusion.

## Overall PCA plot

```{r}
#| label: plotpca-all
#| fig.dim: !expr c(24, 18)
#| warning: false
pca2d = as_tibble(pca$x[, c("PC1", "PC2")], rownames = "condition") |> mutate(is_ctrl = is_ctrl2[-length(is_ctrl2)])
ggplot(pca2d, aes(x = PC1, y = PC2, label = condition, col = is_ctrl)) + 
  scale_colour_manual(values = RColorBrewer::brewer.pal(3, "Set1")[1:2] |> setNames(c("FALSE", "TRUE"))) + 
  geom_point() + ggrepel::geom_label_repel() + coord_fixed()
```

## The same PCA plot as before, but faceted by `group`

`group` comprises a double perturbation and the two respective single perturbations.
We need to do some data wrangling to add the `group` variable, and to add enough copies of the single perturbation rows in the `pca2d` dataframe so that the faceting with `facet_wrap` works.

```{r}
#| label: plotpca-faceted
#| fig.dim: !expr c(12, 36)
#| warning: false
pca2d = mutate(pca2d, 
  group = factor(NA_character_, levels = combsdf$double)
)
for (i in seq_len(nrow(combsdf))) {
  pca2d$group[pca2d$condition == combsdf$double[i] ] = combsdf$double[i]
  s1 = which( pca2d$condition == combsdf$single1[i])[1]      # find relevant existing row
  s2 = which( pca2d$condition == combsdf$single2[i])[1]
  if (is.na(pca2d$group[s1])) 
    pca2d$group[s1] = combsdf$double[i]                                        # use existing row and set `group`
  else
    pca2d = bind_rows(pca2d, mutate(pca2d[s1, ], group = combsdf$double[i]))   # duplicate row
  if (is.na(pca2d$group[s2])) 
    pca2d$group[s2] = combsdf$double[i]                                        # use existing row
  else
    pca2d = bind_rows(pca2d, mutate(pca2d[s2, ], group = combsdf$double[i]))   # duplicate row
}
ggplot(pca2d, aes(x = PC1, y = PC2, label = condition, col = is_ctrl)) + 
  scale_colour_manual(values = RColorBrewer::brewer.pal(3, "Set1")[1:2] |> setNames(c("FALSE", "TRUE"))) + 
  geom_point() + coord_fixed() + 
  geom_hline(yintercept = 0, col = "#808080", linewidth = 0.5) + 
  geom_vline(xintercept = 0, col = "#808080", linewidth = 0.5)  +
  facet_wrap(vars(group), ncol = 6) + theme(legend.position = "none")
filter(pca2d, is.na(group))
```

```{r}
#| label: sdevs
pca$sdev[1:2]^2 |> signif(3)
with(pca2d, c(var(PC1), var(PC2))) |> signif(3)
```





The dimension reduced data with which we continue:

```{r}
#| label: dx
ndim = 120
dx = t(pca$x[, 1:ndim])
dx[seq_len(min(c(3, ndim))), 1:7] |> round(3)
dim(dx)
dx %*% t(dx) |> round(3) |> (\(x) x[seq_len(min(4, ndim)), seq_len(min(4, ndim))])()
```

Note the orthogonality.


## Fit linear models

```{r}
#| label: fitlm
fits = lapply(seq_len(nrow(combs)), function(i) {
  df = tibble(
    y  = dx[, combs$double[i]],
    x1 = dx[, combs$single1[i]],
    x2 = dx[, combs$single2[i]])
  fit = lm(y ~ 0 + x1 + x2, data = df)
  tibble(
    condition = colnames(dx)[combs$double[i]],
    beta1 = coef(fit)["x1"], 
    beta2 = coef(fit)["x2"], 
    data = list(df),
    res = mean(residuals(fit)^2), 
    rsq = summary(fit)$r.squared,
    angle = with(df, 180/pi * acos( sum(x1*x2) / sqrt(sum(x1*x1)*sum(x2*x2)) )),
  )
}) |> bind_rows() |> bind_cols(combs)
```
```{r}
#| label: showfit
#| fig.dim: !expr c(5, 3)
#| out.width: "100%"
#| eval: true
r = range(fits$beta1, fits$beta2)
b = floor(r[1]):ceiling(r[2])
ggplot(fits, aes(x = beta1, y = beta2, colour = rsq)) + 
  geom_abline(slope = -1, intercept = 1) + geom_point() + coord_fixed() + 
  scale_x_continuous(breaks = b) + 
  scale_y_continuous(breaks = b) + 
  scale_colour_continuous(name = expression(R^2))
ggplot(fits, aes(x = beta1, y = beta2, colour = rsq)) + 
  geom_abline(slope = -1, intercept = 1) + geom_point() + coord_fixed() + 
  xlim(-2,2) + ylim(-2,2) +
  scale_colour_continuous(name = expression(R^2)) 
```
```{r}
#| label: plotpca-faceted2
#| fig.dim: !expr c(12, 36)
#| warning: true
pca4facets = lapply(seq_len(nrow(fits)), function(i)
  t(fits$data[[i]][1:2, ]) |> 
    `colnames<-`(c("pca1", "pca2")) |> 
    as_tibble(rownames = "perturbation") |>
    mutate(condition = fits$condition[i])
) |> bind_rows() 
  
```